\section{Unit Testing}
\subsection{Car Query Unit Testing}
The most significant methods ensuring the functionality of the \texttt{CarQuery} class have primarily been unit tested.\\
Retrieving information as JSON and transfering this data to DTO objects has been tested to ensure that this functionality does not have any errors.

Checking that data is received and that this data is correct is tested by requesting a known data set (\texttt{"make=ford"}) and that the received data is of the correct type. Different queuries have also been tested against the API.

Boundary testing is performed by sending a malformed \texttt{CarDto} object as a parameter to the class and checking that a expected exception is thrown. Positive testing is performed as well by sending a correct \texttt{CarDto} object.

\subsection{Persistent Storage Unit Testing}
A subset of the functionality \texttt{PersistentStorage} subsystem has primarily been unit tested. This is due to the fact that much of the funtionality of the sub system is very similar.

As mentioned earlier the system supports create, read, update \& delete functionality of the entities of the \texttt{DriveIT System}. This functionality is very similar for the different data types, which is why testing has mainly been done for Car entities.

Focusing the testing on the underlying frameworks used in the classes does not make sense. Trusting that the developers of the Entity Framework have done extensive testing allows testing the logic in this class instead, which saves time and allows focusing on own logic.

Isolating the \texttt{PersistentStorage} logic requires setting up a mock of the DbContext and DbSet classes of Entity Framework to be able to test that the logic calls the right methods in these classes. The Moq NuGet package provides realtively easy mocking of these classes. 

A list of Car objects is used as the input to a Mock object that is setup to provide the same functionality as the DbSet and DbContext classes. Tests can then be run on these classes.\\
The Moq framework provides methods to verify that a method has been run on the DbContext and thereby confirming that the method performed the correct action. 

The Moq framework has no ability to mock extensions methods, which turned out to make a testing a great deal harder. Since the implementation of \texttt{IPersistentStorage} relies on the extension methods in .NET to include certain results when retrieving entities, this proved to be too hard to test. If a test was to be completed, then entire classes of Entity Framework would have to be mocked which was decided was outside of the scope of this project due to time pressure.

Mocking other evalutation extension methods in .NET was too hard to mock as well, and therefore some functionality of the system could not be tested.

\subsection{DriveIT Web API Unit Testing}
The main part of the \texttt{DriveIT Web API} consists of the public controllers which handles the requests from users. As mentioned earlier, one important thing to remember when testing is to test the implemented logic, and not the framework surrounding it. Therefore we have tested the Web API using mocks of the repository, and by calling the methods directly instead of using HTTP-requests.
Some parts of the controllers cannot be tested this way, which is the parts where the controllers uses the \texttt{ModelState} to check the request for validity, but since this is a built in part of ASP.NET Web API it is assumed that these checks works as expected.
The controllers have been tested with branch coverage, except for the places mentioned above.
The account controller has not been tested, because of time constraints. It was left out because it was mostly auto generated by Visual Studio. 
In the rest of controllers, methods without parameters (get-methods) have been tested to see if they return the right data. Other methods have been tested with valid and invalid input to see that the controllers handles this correctly.

\subsection{DriveIT Windows Client Unit Testing}
By using the MVVM architectural pattern, the application is highly testable since the business logic is away from the view and therefore does not require any actions done in the view. Due to time limitations not all ViewModels have been tested but the \texttt{CarViewModel}'s image gallery function and the \texttt{PasswordCreationViewModel} have been tested and works as an example of how one could extend the test to cover the entire ViewModel subsystem.

For two components tests described, the use of whitebox-testing and branch-testing. Branch-testing gets showcase the NextImage functionality in the \texttt{CarViewModel}. This is done by testing NextPictureWithOnePicture, NextPictureWithTwoPicture, NextPictureWithThreePicture, here there are three different scenarios, either index does not get changed, index swaps between two different values, and index increments until it hits the last index and then returns to the first. \\
Another example of branch testing is visible in the \texttt{PasswordCreationViewModel} here the CheckPassword method is testet. Since the method contains a number of if statements, the testing must make each if-statement return true and false. For this a method is created for each of the if-statements and therefore we reach branch-testing on that method.