\section{Unit Testing}
\subsection{CarQuery Unit Testing}
The most significant methods ensuring the functionality of the \texttt{CarQuery} class have primarily been unit tested.\\
Retrieving information as \textit{JSON} and transferring this data to DTO objects has been tested to ensure that this functionality does not have any errors.

Testing that data is received and that this data is correct is tested by requesting a known data set, e.g. \texttt{"make=ford"}, and checking that the received data is of the anticipated type. Different queries have also been tested against the \texttt{DriveIT Web API}.

Boundary testing is performed by sending a malformed \texttt{CarDto} object as a parameter to the class and checking that the expected exception is thrown. Positive testing is performed as well by sending a correct \texttt{CarDto} object.

\subsection{Persistent Storage Unit Testing}
A subset of the functionality \texttt{PersistentStorage} subsystem has primarily been unit tested.

As mentioned earlier the system supports create, read, update \& delete functionality of the entities of the \texttt{DriveIT System}. This functionality is very similar for the different data types, which is why testing has mainly been done for a specific entity type, namely \texttt{Car}.

Focusing the testing on the underlying frameworks used in the classes does not make sense, since trusting that the developers of the \textit{Entity Framework} have done extensive testing allows testing the logic in the \texttt{Persistent Storage} subsystem instead, which saves time and allows focusing on testing own logic better.

Isolating the \texttt{Persistent Storage} logic requires setting up a mock\footnote{\url{http://en.wikipedia.org/wiki/Mock_object}} of the \texttt{DbContext} and \texttt{DbSet} classes of \textit{Entity Framework} to be able to test that the logic calls the right methods in these classes. The \texttt{Moq} \textit{NuGet} package provides relatively easy mocking of these classes. 

A list of Car objects is used as the input to a \texttt{Mock} object that is set up to provide the same functionality as the \texttt{DbSet} and \texttt{DbContext} classes. Tests can then be run on these classes.\\
The \textit{Moq} framework provides methods to verify that a method has been run on the \texttt{Mock}, thereby confirming that the method performed the correct action. 

The \textit{Moq} framework has no ability to mock extensions methods, which turned out to make a testing a great deal harder. Since the implementation of \texttt{IPersistentStorage} relies on the extension methods in the \textit{.NET Framework} to include certain results when retrieving entities, this proved to be too hard to test. 

If testing was to be thorough, then static methods of the \textit{Entity Framework} would have to be implemented by the \texttt{DriveIT} developers, which was outside of the scope of this project. \\Therefore some functionality of the system could not be tested.

\subsection{DriveIT Web API Unit Testing}
\subsubsection{Scope}
The \texttt{DriveIT Web API} consists of several API Controllers, which are responsible for an entity each. We have tested the main entity controllers:
\begin{itemize}
	\item CarsController
	\item CommentsController
	\item ContactRequestsController
	\item CustomersController
	\item EmployeesController
	\item SalesController
\end{itemize}
The account controller has not been tested, because of time constraints. It was left out because it was mostly auto generated by Visual Studio.\\

The controllers have been tested with branch coverage, except for the places mentioned below.
\subsubsection{Approach}
As mentioned earlier, one important thing to remember when testing is to test the implemented logic, and not the framework surrounding it. Therefore we have tested the Web API using mocks of the repository, and by calling the methods directly instead of using HTTP-requests.
Some parts of the controllers cannot be tested this way, which is the parts where the controllers uses the \texttt{ModelState} to check the request for validity, but since this is a built in part of ASP.NET Web API it is assumed that these checks works as expected.

Methods without parameters (get-methods) are tested to see if they return the right data. Other methods are tested with valid and invalid input to see that the controllers handles this correctly.

\subsubsection{Requirements}
All unit tests should succeed after every extension or refactoring of the DriveIT Web API.

\subsubsection{Components}
The test suite is a collection of test drivers, used to test the functionality of the controllers.
Test stubs: The tests uses a mocked IPersistentStorage which has been setup to support the required functionality using the Moq\footnote{\url{https://github.com/Moq/moq4/blob/master/README.md}} framework.
The unit tests of the \texttt{DriveIT Web API} are located in the \texttt{DriveIT.Web.Tests} assembly.

\subsubsection{Results}
In the current version of \texttt{DriveIT Web API} the tests have completed with success. This does not mean that the Wep API is bug-free, but it gives us more confidence that the controllers work as intended.

\subsection{DriveIT Windows Client Unit Testing}
By using the MVVM architectural pattern, the application is highly testable since the business logic is away from the view and therefore does not require any actions done in the view. Due to time limitations not all ViewModels have been tested but the \texttt{CarViewModel}'s image gallery function and the \texttt{PasswordCreationViewModel} have been tested and works as an example of how one could extend the test to cover the entire ViewModel subsystem.

For two components tests described, the use of whitebox-testing and branch-testing. Branch-testing gets showcase the NextImage functionality in the \texttt{CarViewModel}. This is done by testing NextPictureWithOnePicture, NextPictureWithTwoPicture, NextPictureWithThreePicture, here there are three different scenarios, either index does not get changed, index swaps between two different values, and index increments until it hits the last index and then returns to the first. \\
Another example of branch testing is visible in the \texttt{PasswordCreationViewModel} here the CheckPassword method is testet. Since the method contains a number of if statements, the testing must make each if-statement return true and false. For this a method is created for each of the if-statements and therefore we reach branch-testing on that method.\\

All Tests in the \texttt{DriveIT Windows Client} passes the component unit-tests.
