\section{Unit Testing}
\subsection{PersistentStorage Unit Testing}
A subset of the functionality of the \texttt{PersistentStorage} subsystem has primarily been unit tested.

As mentioned earlier the system supports create, read, update \& delete functionality of the entities of the \texttt{DriveIT System}. This functionality is very similar for the different entities, which is why testing has mainly been done for a specific entity type, namely \texttt{Sale}.

Focusing the testing on the underlying frameworks used in the classes does not make sense, since trusting that the developers of the \textit{Entity Framework} have done extensive testing allows testing the logic in the \texttt{PersistentStorage} subsystem instead, which saves time and allows focusing on testing specific \texttt{DriveIT System} logic in depth.

Isolating the \texttt{PersistentStorage} logic requires setting up a mock\footnote{\url{http://en.wikipedia.org/wiki/Mock_object}} of the \texttt{DbContext} and \texttt{DbSet} classes of \textit{Entity Framework} to be able to test that the logic calls the right methods in these classes. The \textit{Moq}\footnote{\url{https://github.com/Moq/moq4}} framework provides relatively easy mocking of these classes. 

A list of \texttt{Sale} objects is used as the input to a \texttt{Mock} object that is set up to provide the same functionality as the \texttt{DbSet} and \texttt{DbContext} classes. Tests can then be run on these classes.\\
The \textit{Moq} framework provides methods to verify that a method has been run on the \texttt{Mock}, thereby confirming that the method performed the correct action. 

The \textit{Moq} framework has no ability to mock extension methods, which turned out to make testing a great deal harder. Since the implementation of \texttt{IPersistentStorage} relies on the extension methods in the \textit{.NET Framework} to include certain results when retrieving entities, this proved to be too hard to test. 

If testing was to be thorough, static methods of the \textit{Entity Framework} would have to be implemented by the \texttt{DriveIT} developers, which was outside of the scope of this project. \\Therefore some functionality of the system could not be tested.

\subsection{DriveIT Web API Unit Testing}
The \texttt{DriveIT Web API} consists of several \texttt{APIController}s, which are responsible for one entity each. The following \texttt{Controllers} have been tested:
\begin{itemize}
	\item CarsController
	\item CommentsController
	\item ContactRequestsController
	\item CustomersController
	\item EmployeesController
	\item SalesController
\end{itemize}
The \texttt{AccountController} has not been tested because of time constraints and due to the fact that it was mostly auto generated by Visual Studio.\\

The controllers have been tested with branch coverage, except for the places mentioned in the section below.\\

As mentioned earlier, one important thing to remember when testing is to test the implemented logic, and not the framework surrounding it. Therefore we have tested the \texttt{DriveIT Web API} using mocks of the repository and by calling the methods directly instead of using \textit{HTTP} requests.
Some parts of the \texttt{Controllers} cannot be tested this way, which is the parts where the \texttt{Controllers} use the \texttt{ModelState} to check the request for validity, but since this is a built in part of \textit{ASP.NET Web API} it is assumed that these checks work as expected.\\

Methods without parameters, \texttt{GET} methods, are tested to see if they return the right data. Other methods are tested with valid and invalid input to see that the \texttt{Controller}s handle this data correctly.

All unit tests should succeed after every extension or refactoring of the \texttt{DriveIT Web API}.\\

The test suite is a collection of test drivers, used to test the functionality of the \texttt{Controllers}.
Mocks have been used for tests stubs for mocking \texttt{IPersistentStorage}. The tests use a mocked IPersistentStorage which has been setup to support the required functionality using the \textit{Moq} framework.
The unit tests of the \texttt{DriveIT Web API} are located in the \texttt{DriveIT.Web.Tests.ApiControllers} namespace.\\

In the current version of \texttt{DriveIT Web API} the tests have completed with success. This does not mean that the \texttt{DriveIT Web API} is bug-free, but it provides more confidence that the controllers work as intended.

\subsection{DriveIT Windows Client Unit Testing}
By using the \textit{MVVM} architectural pattern, the application is highly testable since the business logic is separated from the \textit{View} and therefore does not require any actions done in the \textit{View}. Due to time limitations not all \texttt{ViewModels} have been tested, but the image gallery functions of \texttt{CarViewModel} and the \texttt{PasswordCreationViewModel} have been tested and work as an example of how one could extend the test suite to cover the entire \texttt{ViewModel} subsystem.

For the tests of the two components described above, whitebox testing and branch testing has been used, e.g. the \texttt{NextImage} functionality in the \texttt{CarViewModel} has been whitebox tested with branch coverage. This is done by the test methods \texttt{NextPictureWithOnePicture}, \texttt{NextPictureWithTwoPicture}, \texttt{NextPictureWithThreePicture}. Here there are three different scenarios, either the image gallery index does not change, the index swaps between two different values, or index increments until it hits the last index and then returns to the first. 

Another example of white box testing with branch coverage is visible in the \texttt{PasswordCreationViewModel}. Here the \texttt{CheckPassword} method is tested. Since the method contains a number of if-statements, the testing must make sure that every if-statement is entered. For this a test method is created for each of the if-statements and therefore we reach branch coverage on that method.\\

All tests in the \texttt{DriveIT Windows Client} pass the component unit-tests.
